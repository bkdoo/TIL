## 알고리즘 설계 패러다임 - 무식하게 풀기

- 무식하게 풀기(brute-force)

  - 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법

- 완전 탐색(exhaustive search)

  - 가능한 방법을 모두 만들어 보는 알고리즘
  - 컴퓨터의 장점을 가장 잘 이용하는 방법
  - 완전 탐색은 더 빠른 알고리즘의 기반이 되기도 하기 때문에 잘 익혀둘 필요가 있다.

- 재귀 함수(recursion, recursive function)

  - 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수
  - 재귀 호출은 다양한 알고리즘을 구현하는 데 매우 유용하게 사용할 수 있는 도구이다.
  - 문제의 특성에 따라 재귀 호출은 코딩을 훨씬 간편하게 해 줄 수 있는 강력한 무기가 된다.
  - 재귀 호출을 이용하면 특정 조건을 만족하는 조합을 모두 생성하는 코드를 쉽게 작성할 수 있다.
  - 때문에 재귀 호출은 완전 탐색을 구현할 때 아주 유용한 도구이다.
  - 입력이 잘못되거나 범위에서 벗어난 경우도 기저 사례로 택해서 맨 처음에 처리하면, 함수를 호출하는 시점에서 이러한 오류를 검사할 필요가 없다.
  - 재귀 함수는 항상 한군데 이상에서 호출되기 때문에, 이러한 습관은 반복적인 코드를 제거하는 데 큰 도움이 된다.

- 예제

  - 보글 게임 : 5 x 5 크기의 알파벳 격자에서 상하좌우&대각선으로 인잡한 칸들의 글자들을 이어서 단어를 찾아내는 게임

  - 완전 탐색을 이용해, 단어를 찾아낼 때까지 모든 인접한 칸을 하나씩 시도해보는 방법

  - 기저 사례의 선택 : 더 이상의 탐색 없이 간단히 답을 낼 수 있는 경우

    - 위치 (y,x)에 있는 글자가 원하는 단어의 첫글자가 아닌 경우 항상 실패
    - 원하는 단어가 한 글자인 경우 항상 성공

  - 구현 코드

    ```java
    	final int[] dx = {-1, -1, -1, 1, 1, 1, 0, 0};
    	final int[] dy = {-1, 0, 1, -1, 0, 1, -1, 1};
    	
    	boolean hasWord(int y, int x, String word) {
    		// 기저 사례 1: 시작 위치가 범위 밖이면 무조건 실패
    		if (!inRange(y,x)) return false;
    		// 기저 사례 2: 첫 글자가 일치하지 않으면 실패
    		if (!board[y][x].equals(word.substring(0,1))) return false;
    		// 기저 사례 3: 단어 길이가 1이면 성공
    		if(word.length()==1) return true;
    		
    		// 인접한 여덟 칸을 검사한다.
    		for (int i = 0; i < 8; i++) {
    			int nextY = y + dy[i];
    			int nextX = x + dx[i];
    			// 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다.
    			if (hasWord(nextY, nextX, word.substring(1))) {
    				return true;
    			}
    		}
    		
    		return false;
    	}
    ```

- 시간 복잡도 분석

  - 완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어보기만 하면 된다.
  - 최악의 경우는 답이 아예 존재하지 않는 경우인 때가 많다.
  - 후보의 수는 지수적으로 증가하기 때문에 짧은 경우에만 완전 탐색으로 해결할 수 있다.

- 완전 탐색 레시피

  - 완전 탐색으로 해결하기 위한 과정은 대략 다음과 같다.
    - 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례한다. 만약 시간 안에 계산할 수 없다면 다른 설계 패러다임을 적용해야 한다. (동적 계획법 등)
    - 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 된다.
    - 그중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.
    - 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로 이를 기저 사례로 선택해 처리한다.

- 이론적 배경 : 재귀 호출과 부분 무제

  - 재귀 호출에서 짚고 넘어가야 할 중요한 개념 중 하나로 문제와 부분 문제의 정이가 있다.
  - 다음 두 정의를 살펴보자.
    - 주어진 자연수 수열을 정렬하라.
    - {16, 7, 9 ,1, 31}을 정렬하라.
  - 전자는 특정한 입력을 지정하지 않은 반면, 후자는 특정한 입력을 지정한다.
  - '문제'란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다.
  - 따라서 앞의 두 정의 중 엄밀하게는 후자만을 문제의 정의라고 할 수 있다.
  - Boggle 게임에서 문제는 '게임판에서의 현재 위치와 단어가 주어질 때 해당 단어를 이칸에서부터 시작해서 찾을 수 있는가?' 로 정의된다.
    - 현재 위치에 단어의 첫 글자가 있는가?
    - 윗칸에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
    - 왼쪽 윗칸에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
    - .....
  - 2번째 항목 이후는 원래 문제에서 한 조각을 떼어냈을 뿐, 형식이 같은 또 다른 문제를 푼 결과이다.
  - 이런 문제들을 원래 문제의 부분 문제라고 한다.
